# HTTP 缓存

> 重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。

## 1. 各种类型的缓存

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。

- 缓存的种类有很多,其大致可归为两类：`私有与共享缓存`。共享缓存存储的响应能够被多个用户使用，私有缓存只能用于单独用户。

下文将主要介绍`浏览器缓存`，除此之外还有代理缓存、网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上，为站点和 web 应用提供更好的稳定性、性能和扩展性。

**常见的 HTTP 缓存只能存储 `GET` 响应，对于其他类型的响应则无能为力。**

## 2. 缓存规则

为了方便理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息（实际上静态资源是被缓存到了内存和磁盘中），在浏览器第一次请求数据时，此时缓存数据库没有对应的缓存数据，则需要请求服务器，服务器会将缓存规则和数据返回，浏览器将缓存规则和数据存储进缓存数据库。

我们可以将其分为两大类`强缓存`、`协商缓存`

### 2.1 强缓存

浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求`(200 from memory/disk cache)`

**HTTP 1.0**

服务器使用的响应头字段为 `Expires` ，值为未来的绝对时间（时间戳），浏览器请求时的当前时间超过了 Expires 设置的时间，代表缓存失效，需要再次向服务器发送请求，否则都会直接从缓存数据库中获取数据。

------

**HTTP 1.1**

`Cache-Control` 是最重要的规则，默认为private。

```
private     私有缓存
public      共享缓存
max-age     缓存的内容将在 xxx 秒后失效
no-cache    需要使用对比缓存来验证缓存数据
no-store    所有内容都不会缓存，强缓存、协商缓存都不会触发
```



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/9/1696260478bcf239~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



***注意：在 HTTP 1.0 版本中，`Expires` 字段的绝对时间是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差，在 HTTP 1.1 版本中，因为 `Cache-Control` 的值 `max-age=xxx` 中的 xxx 是以秒为单位的相对时间，所以在浏览器接收到资源后开始倒计时，规避了 HTTP 1.0 中缓存命中存在误差的缺点，为了兼容低版本 HTTP 协议，正常开发中两种响应头会同时使用，`HTTP 1.1 版本的实现优先级高于 HTTP 1.0`。***



### 2.2 协商缓存

浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回`304`状态码，通知客户端比较成功，可以使用缓存数据。

**HTTP 1.0**

- **If-Modified-Since/Last-Modified** 这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是`If-Modified-Since`，而服务端的是`Last-Modified`，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能`精确到1s以内`。

**HTTP 1.1**

- **If-None-Match/E-tag** 这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是`If-None-Match`，而服务端的是`E-tag`，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于`FileEtag INode Mtime Size`生成，只要文件变，指纹就会变，而且`没有1s精确度的限制`。

------



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/9/16962616b536913b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/9/169626249a2001f4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



------



为了使缓存策略更加健壮、灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略会同时使用，**甚至强制缓存和协商缓存也会同时使用**，

对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，超出有效时间，执行协商缓存策略，

对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求头 If-None-Match 和 If-Modified-Since 发送给服务器，由服务器校验同时设置新的强制缓存，校验通过并返回 304 状态码时，浏览器直接使用缓存，如果协商缓存也未命中，则服务器重新设置协商缓存的标识。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/9/1696230b5fc2005b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



## 3. 带Vary头的响应

> Vary HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。

**当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应**。

使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助 Google 或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入Cloaking。